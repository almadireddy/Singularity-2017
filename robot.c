#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  liftRight,      sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  liftLeft,       sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           leftFront,     tmotorVex393TurboSpeed_HBridge, openLoop)
#pragma config(Motor,  port2,           leftMiddle,    tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           leftBack,      tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           liftLeftTop,   tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port5,           liftLeftBottom, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           liftRightTop,  tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port7,           liftRightBottom, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           rightBack,     tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           rightMiddle,   tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port10,          rightFront,    tmotorVex393TurboSpeed_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)
#pragma competitionControl(Competition)
#include "Vex_Competition_Includes.c"

#include "auton.c"

void lift(int power) {
	motor[liftLeftTop] = motor[liftLeftBottom] = motor[liftRightTop] = motor[liftRightBottom] = power;
}

void liftControl() {
	if (vexRT[Btn6U])
		lift(127);
	else if (vexRT[Btn6D])
		lift(-127);
	else
		lift(0);
}

void driveL(float power) {
	motor[leftBack] = motor[leftMiddle] = motor[leftFront] = power;
}

void driveR(float power) {
	motor[rightBack] = motor[rightMiddle] = motor[rightFront] = power;
}

int t = 15;
int ch3, ch1;

void arcadeDrive() {
	if (abs(vexRT[Ch3]) > t)
		ch3 = vexRT[Ch3];
	else
		ch3 = 0;

	if (abs(vexRT[Ch1]) > t)
		ch1 = vexRT[Ch1];
	else
		ch1 = 0;

	driveL(ch3 + ch1);
	driveR(ch3 - ch1);
}


// Lift PID //
float liftKp = 0.3;
float liftKi = 0.1;
float liftKd = 0.4;
float liftTarget, liftError, liftLastError, liftIntegral, liftDerivative, liftOutput;
float liftIntegralCap = 50;
float dt = 25;


task liftPID() {
	liftLastError = 0;
	liftIntegral  = 0;

	while (true) {
		liftError = nMotorEncoder[liftRightTop] - nMotorEncoder[liftLeftTop];
		liftIntegral += dt * (liftError + liftLastError)/2;

		if(liftError == 0)
			liftIntegral = 0;
		if(fabs(liftIntegral) > liftIntegralCap)
			liftIntegral = liftIntegralCap;

		liftDerivative = (liftError - liftLastError)/dt;
		liftOutput = liftKp*liftError + liftKi*liftIntegral + liftKd*liftDerivative;
		liftLastError = liftError;
		wait1Msec(dt);
	}
}
// End Lift PID //

// Drive PID //
float driveKp = 0.3;
float driveKi = 0.1;
float driveKd = 0.4;
float driveCurrentValue;
float driveTarget, driveError, driveLastError, driveIntegral, driveDerivative, driveOutput;
float driveIntegralCap = 50;
float ticksPerRevolution = 360.0;
float ticksPerInch = ticksPerRevolution / (4 * PI);
bool driveRunning = true;
float driveMax = 80;
float driveMin = -80;
float secondary, constant, difference;


task drivePID() {
	driveLastError  = 0;
	driveIntegral   = 0;
	while( true ) {
		if( driveRunning ) {
			if (abs(SensorValue[leftEncoder]) > abs(SensorValue[rightEncoder])) {
				driveCurrentValue = SensorValue[rightEncoder];
				secondary = -SensorValue[leftEncoder];
				difference = abs(secondary) - abs(driveCurrentValue);
				driveL(-driveOutput + constant*difference);
				driveR(-driveOutput);
			}
			else {
				driveCurrentValue = SensorValue[leftEncoder];
				secondary = SensorValue[rightEncoder];
				difference = abs(secondary) - abs(driveCurrentValue);
				driveL(-driveOutput);
				driveR(-driveOutput + constant*difference);
			}

			driveError = driveCurrentValue - driveTarget;

			if( driveKi != 0 ) {
				if( abs(driveError) < driveIntegralCap)
					driveIntegral = driveIntegral + driveError;
				else
					driveIntegral = 0;
			}
			else
				driveIntegral = 0;

			driveDerivative = driveError - driveLastError;
			driveLastError  = driveError;

			driveOutput = (driveKp * driveError) + (driveKi * driveIntegral) + (driveKd * driveDerivative);

			if ( driveOutput > driveMax )
				driveOutput = driveMax;
			if ( driveOutput < driveMin )
				driveOutput = driveMin;
		}
		else {
			driveError      = 0;
			driveLastError  = 0;
			driveIntegral   = 0;
			driveDerivative = 0;
		}

		wait1Msec(dt);
	}
}

void go(float inches) {
	SensorValue[leftEncoder] = SensorValue[rightEncoder] = 0;

	driveTarget = inches * ticksPerInch;
}

void pre_auton() {
	bStopTasksBetweenModes = true;
}

task autonomous() {
	driveKp = 0.3;
	driveKi = 0.05;
	driveKd = 0.0;
	startTask(drivePID);
	go(24);
}


task usercontrol() {
	startTask(liftPID);

	while (true) {
		arcadeDrive();
		liftControl();
	}
}
